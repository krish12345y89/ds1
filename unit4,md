

# ğŸŸ© **UNIT-4 â€” SORTING & HASHING (FULL EXAM-NOTES in Hinglish)**

---

# â­ **PARTâ€“A: SORTING (Very Important)**

Sorting = elements ko **increasing ya decreasing** order me arrange karna.

---

# ğŸ”¶ **1. Selection Sort**

### **Idea:**

Har step me **minimum element find** karke correct position par swap karo.

### **Algorithm:**

1. i = 0 se nâ€“1 tak
2. min_index find karo (i to nâ€“1)
3. Swap arr[i] with arr[min_index]

### **Time Complexity:**

* Best = O(nÂ²)
* Worst = O(nÂ²)
* Space = O(1)

### **Use:**

Chota array, easy implementation.

---

# ğŸ”¶ **2. Bubble Sort**

### **Idea:**

Adjacent elements ko compare karke **bade element ko bubble karke end tak** bhejte hain.

### **Process:**

* Har pass me largest element end pe chala jata hai.

### **Complexity:**

* Best = O(n) (if optimized with swap flag)
* Worst = O(nÂ²)

Face-to-face exam me bubble explain karna must hota hai.

---

# ğŸ”¶ **3. Insertion Sort**

### **Idea:**

List ko 2 parts me treat karte hain: **sorted + unsorted**
Har element ko correct position me insert karte hain.

### **Complexity:**

* Best = O(n)
* Worst = O(nÂ²)
* Space = O(1)

### **Use:**

Small datasets, nearly sorted arrays.

---

# ğŸ”¶ **4. Quick Sort (Most Important)**

### **Idea:**

Divide & Conquer

* Pivot choose
* Smaller elements left
* Larger elements right

### **Time:**

* Best = O(n log n)
* Avg = O(n log n)
* Worst = O(nÂ²) (when array already sorted)

### **Space:** O(log n) recursion

---

# ğŸ”¶ **5. Merge Sort**

### **Idea:**

Array ko half-half divide â†’ recursively sort â†’ merge.

### **Time:**

* Best = O(n log n)
* Worst = O(n log n)
* Stable & good for large data

### **Space:** O(n)

---

# ğŸ”¶ **6. Heap Sort**

### **Idea:**

Binary heap (max heap) banate hain â†’ max element extract â†’ array sorted.

### **Time:**

* O(n log n)
* Space: O(1)

---

# ğŸ“Œ **Sorting Comparison Table (Exam Favourite)**

| Algorithm | Best       | Worst      | Space    | Stable? |
| --------- | ---------- | ---------- | -------- | ------- |
| Selection | O(nÂ²)      | O(nÂ²)      | O(1)     | No      |
| Bubble    | O(n)       | O(nÂ²)      | O(1)     | Yes     |
| Insertion | O(n)       | O(nÂ²)      | O(1)     | Yes     |
| Quick     | O(n log n) | O(nÂ²)      | O(log n) | No      |
| Merge     | O(n log n) | O(n log n) | O(n)     | Yes     |
| Heap      | O(n log n) | O(n log n) | O(1)     | No      |

---

# â­ **PARTâ€“B: HASHING**

Hashing = fast searching ka technique
Goal â†’ **O(1) average time** for search, insert, delete.

---

# ğŸ”¶ **1. Hash Function**

Converts key â†’ index
`h(key) = key % table_size`

### Good hash function:

âœ” Uniform distribution
âœ” Fast to compute
âœ” Minimum collisions

---

# ğŸ”¶ **2. Collision**

Jab 2 keys same index pe aaye â†’ collision hota hai.

---

# â­ **Collision Resolution Techniques**

---

# ğŸ”µ **1. Open Addressing**

### **(A) Linear Probing**

Index fill ho to

```
index = (index + 1) % size
```

Problem: Clustering

---

### **(B) Quadratic Probing**

```
index = (h(key) + i^2) % size
```

Less clustering.

---

### **(C) Double Hashing**

```
index = h1(key) + i * h2(key)
```

Best among open addressing.

---

# ğŸ”µ **2. Separate Chaining (IMPORTANT)**

Har index par ek **linked list** bani hoti hai.

Collision â†’ same index par linked list me add.

**Pros:**
âœ” No clustering
âœ” Easy deletion

**Time:**

* Best = O(1)
* Worst = O(n)

---

# â­ **Load Factor**

```
Î± = number of elements / table size
```

Load factor high â†’ collisions badh jate hain.

---

# â­ **3. Applications of Hashing**

* Password storage
* Databases
* Compilers (symbol table)
* Caching
* Indexing

---

# ğŸ“Œ **Graph â€“ Basic Concepts (As per syllabus)**

### Includes:

âœ” Graph meaning
âœ” Types (directed, undirected, weighted, unweighted)
âœ” Representation â†’ **Adjacency List & Matrix**
âœ” BFS & DFS
âœ” Complexity of traversals

(Ye main already fully de chuka hoon â€” agar chaho to isko bhi summarize kar du.)

---

# ğŸ’¥ **MOST IMPORTANT 10 MARKERS (UNIT-4)**

1. Selection vs Insertion vs Bubble (table compare)
2. Quick sort algorithm + example
3. Merge sort algorithm + merge function
4. Collision resolution techniques
5. Hash function characteristics
6. Linear vs quadratic vs double hashing
7. Adjacency matrix vs adjacency list
8. BFS vs DFS
9. Heap creation + heap sort
10. Hashing applications

---
